
#import <UIKit/UIKit.h>

@interface MQTTClientViewController : UIViewController

@end

/**
 1、 什么是MQTT?
 
 MQTT（MessageQueueing Telemetry Transport Protocol）消息队列遥感传输协议
 
 是由IBM公司推出的一种基于轻量级代理的发布/订阅模式的消息传输协议，运行在TCP协议栈之上，为其提供有序、可靠、双向连接的网络连接保证。
 由于其开放、简单和易于实现所以能够应用在资源受限的环境中，对于M2M和物联网应用程序来说是一个相当不错的选择。
 
 2、 为什么要用MQTT？
 
 MQTT协议是针对如下情况设计的：
 
 M2M（Machine to Machine） communication，机器端到端通信，比如传感器之间的数据通讯 因为是Machine to Machine，需要考虑： Machine，或者叫设备，比如温度传感器，硬件能力很弱，协议要考虑尽量小的资源消耗，比如计算能力和存储等 M2M可能是无线连接，网络不稳定，带宽也比较小
 
 MQTT的特点:
 
 发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于1. 这里是列表文本XMPP，但是MQTT的信息冗余远小于XMPP.
 
 对负载内容屏蔽的消息传输。
 
 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。
 
 三种消息传输方式QoS：
 
 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。
 
 1代表“至少一次”，确保消息到达，但消息重复可能会发生。
 
 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 备注：由于服务端采用Mosca实现，Mosca目前只支持到QoS 1
 
 如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了（客户端登录的时候要指明支持的QoS级别，同时发送消息的时候也要指明这条消息支持的QoS级别），如果需要客户端保证能接收消息，需要指定QoS为1，如果同时需要加入客户端不在线也要能接收到消息，那么客户端登录的时候要指定session的有效性，接收离线消息需要指定服务端要保留客户端的session状态。
 
 mqtt基于订阅者模型架构，客户端如果互相通信，必须在同一订阅主题下，即都订阅了同一个topic，客户端之间是没办法直接通讯的。订阅模型显而易见的好处是群发消息的话只需要发布到topic，所有订阅了这个topic的客户端就可以接收到消息了。
 
 发送消息必须发送到某个topic，重点说明的是不管客户端是否订阅了该topic都可以向topic发送了消息，还有如果客户端订阅了该主题，那么自己发送的消息也会接收到。
 
 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合“在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。
 
 使用Last Will和Testament特性通知有关各方客户端异常中断的机制。Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。Testament：遗嘱机制，功能类似于Last Will 。
 
 发布订阅模式
 使得消息发布者和订阅者不需要了解对方，发布者和订阅者不需要交互， 发布者无需等待订阅者确认而导致锁定，这和我们iOS中的通知是有区别的，iOS中的通知是同步的。。
 
 主题
 订阅者像订阅通知一样订阅主题，发布者发布主题消息之后，MQTT代理就会将消息推送到相应的订阅者
 
 代理
 作为一个中继站的感觉~，管理连接，处理消息发布和订阅的具体事宜。
 
 服务质量（Quality of Service –QoS）
 0
 “至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。
 至多发送一次，发送即丢弃。没有确认消息，也不知道对方是否收到。
 针对的消息不重要，丢失也无所谓。
 网络层面，传输压力小。
 
 1
 “至少一次”，确保消息到达，但消息重复可能会发生。
 所有QoS level 1都要在可变头部中附加一个16位的消息ID。
 SUBSCRIBE和UNSUBSCRIBE消息使用QoS level 1。
 针对消息的发布，Qos level 1，意味着消息至少被传输一次。
 发送者若在一段时间内接收不到PUBACK消息，发送者需要打开DUB标记为1，然后重新发送PUBLISH消息。因此会导致接收方可能会收到两次PUBLISH消息。针对客户端发布消息到服务器的消息处理流程：
 发布者（客户端/服务器）若因种种异常接收不到PUBACK消息，会再次重新发送PUBLISH消息，同时设置DUP标记为1。接收者以服务器为例，这可能会导致服务器收到重复消息，按照流程，broker（服务器）发布消息到订阅者（会导致订阅者接收到重复消息），然后发送一条PUBACK确认消息到发布者。
 　　在业务层面，或许可以弥补MQTT协议的不足之处：重试的消息ID一定要一致接收方一定判断当前接收的消息ID是否已经接受过，但一样不能够完全确保，消息一定到达了。
 
 2
 “只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。
 仅仅在PUBLISH类型消息中出现，要求在可变头部中要附加消息ID。
 　　级别高，通信压力稍大些，但确保了仅仅传输接收一次。
 　　先看协议中流程图，Client -> Server方向，会有一个总体印象：
 Server端采取的方案a和b，都包含了何时消息有效，何时处理消息。两个方案二选一，Server端自己决定。但无论死采取哪一种方式，都是在QoS level 2协议范畴下，不受影响。若一方没有接收到对应的确认消息，会从最近一次需要确认的消息重试，以便整个（QoS level 2）流程打通。
 
 消息类型
 MQTT协议下拥有14种不同的消息类型
 
 MQTTConnect = 1,  //客户端连接到MQTT代理
 MQTTConnack = 2, //连接确认的消息
 MQTTPublish = 3, //新发布消息
 MQTTPuback = 4,  //新发布消息确认
 MQTTPubrec = 5,  //消息发布  已记录
 MQTTPubrel = 6,  //消息发布  已释放
 MQTTPubcomp = 7, //消息发布完成
 MQTTSubscribe = 8,    //订阅
 MQTTSuback = 9,       //订阅回执
 MQTTUnsubscribe = 10, //取消订阅
 MQTTUnsuback = 11,    //取消订阅的回执吧
 MQTTPingreq = 12, //心跳消息
 MQTTPingresp = 13,//确认心跳
 MQTTDisconnect = 14 //客户端终止连接

 */
